<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Jurjan Brust - Controlling a VFD with an ESP8266</title><meta name=description content="Jurjan Brust Blog"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property='og:title' content='Controlling a VFD with an ESP8266'><meta property='og:image' content='https://jurjanbrust.github.io/img/vfd/IMG_5697.JPG'><meta property='og:description' content='Jurjan Brust Blog'><meta property='og:url' content='https://jurjanbrust.github.io/posts/iot/vfd/'><link rel=stylesheet href=https://jurjanbrust.github.io/css/bootstrap.min.css><link rel=stylesheet href="//fonts.googleapis.com/css?family=Roboto:400,300,700,400italic"><link rel=stylesheet href="//fonts.googleapis.com/css?family=Montserrat:100"><link rel=stylesheet href=https://jurjanbrust.github.io/css/font-awesome.min.css><link rel=stylesheet href=https://jurjanbrust.github.io/css/owl.carousel.css><link rel=stylesheet href=https://jurjanbrust.github.io/css/owl.theme.css><link href=https://jurjanbrust.github.io/css/style.green.css rel=stylesheet id=theme-stylesheet><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link href=https://jurjanbrust.github.io/css/custom.css rel=stylesheet><link rel="shortcut icon" href=https://jurjanbrust.github.io/img/favicon.png></head><body><div id=all><div class=container-fluid><div class="row row-offcanvas row-offcanvas-left"><div id=sidebar class="col-xs-6 col-sm-4 col-md-3 sidebar-offcanvas"><div class=sidebar-content><a href=/><img src=/img/jurjan.png class=avatar></a><h1 class=sidebar-heading><a href=https://jurjanbrust.github.io/>Jurjan Brust</a></h1><p class=sidebar-p>SharePoint | M365 | Azure | IoT</p><ul class=sidebar-menu><li><a href=https://jurjanbrust.github.io/posts/>HOME</a></li><li><a href=https://jurjanbrust.github.io/categories/projects>PROJECTS</a></li><li><a href=https://jurjanbrust.github.io/categories/azure>AZURE</a></li><li><a href=https://jurjanbrust.github.io/categories/sharepoint>SHAREPOINT / M365</a></li><li><a href=https://jurjanbrust.github.io/about/>ABOUT</a></li><li><a href=https://jurjanbrust.github.io/contact/>CONTACT</a></li></ul><p class=social><a href=/index.xml data-animate-hover=pulse class=email><i class="fa fa-rss"></i>
</a><a href=https://www.linkedin.com/in/jurjanbrust/ data-animate-hover=pulse class=external><i class="fa fa-linkedin"></i>
</a><a href=https://twitter.com/jurjanbrust data-animate-hover=pulse class="external twitter"><i class="fa fa-twitter"></i>
</a><a href=https://www.instagram.com/jurjanbrust/ title class="external instagram"><i class="fa fa-instagram"></i>
</a><a href=https://github.com/jurjanbrust data-animate-hover=pulse class=external><i class="fa fa-github"></i></a></p><div class=copyright><p class=credit>&copy;2025 Jurjan Brust</p></div></div></div><div class="col-xs-12 col-sm-8 col-md-9 content-column white-background"><div class="small-navbar visible-xs"><button type=button data-toggle=offcanvas class="btn btn-ghost pull-left"> <i class="fa fa-align-left"></i>Menu</button><h1 class=small-navbar-heading><a href=https://jurjanbrust.github.io/>Jurjan Brust</a></h1></div><div class=row><div class=col-lg-8><div class=content-column-content><h1>Controlling a VFD with an ESP8266</h1><p>In this project I have build an information-display using an ESP8266 to control a Vacuum Fluorescent Display (VFD).</p><p>I choose the ESP8266 for this because of its capability to communicate over WIFI.
You can visit my <a href=https://github.com/jurjanbrust/esp8266_vfd>github repository</a> to see the code that I have written for this and also check out more details about this project.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/3-wzvdbAAj8?autoplay=1&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=1&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><div class="row justify-content-center"><div class=col-md-12><div class=row><a href="/img/vfd/IMG_5674.JPG?image=251" data-toggle=lightbox data-gallery=example-gallery class=col-sm-4 data-max-width=600><img src="/img/vfd/IMG_5674.JPG?image=251" class=img-fluid>
</a><a href="/img/vfd/IMG_5678.JPG?image=252" data-toggle=lightbox data-gallery=example-gallery class=col-sm-4 data-max-width=600><img src="/img/vfd/IMG_5678.JPG?image=252" class=img-fluid>
</a><a href="/img/vfd/IMG_E5687.JPG?image=253" data-toggle=lightbox data-gallery=example-gallery class=col-sm-4 data-max-width=600><img src="/img/vfd/IMG_E5687.JPG?image=252" class=img-fluid>
</a><a href="/img/vfd/IMG_4308.JPG?image=254" data-toggle=lightbox data-gallery=example-gallery class=col-sm-4 data-max-width=600><img src="/img/vfd/IMG_4308.JPG?image=252" class=img-fluid></a></div></div></div><p><h2 id=hardware-and-software-design-choices>Hardware and Software design choices</h2><p>The scheme displayed below shows the components involved. First there is an ESP8266 that is being used as the controller of the VFD. Because the serial port of the VFD is inverted an invertor is needed to invert the bits transmitted on the serial port. I used a sn74hc04n for this, but this is probably a bit of overkill.</p><p><img src=/img/vfd/Scheme.png alt=Scheme></p><p>For the software part I decided to keep the software on the ESP as simple as possible. So the ESP only has logic to control the display, display the time and do some fancy animation tricks.</p><p>The Web-API contains all the logic to gather and prepare the information that needs to be displayed on the VFD. Coding in C# is way easier to do than coding in C++ and debugging is also a lot faster. So separating this into two projects has been a great choice.</p><p>Currently the WEB-API gathers the following kinds of information:</p><ol><li>weather forecast</li><li>traffic information</li><li>Fitbit information</li><li>Calendar (central family)</li></ol><p>Other possible future things to add are:</p><ol><li>Tesla car status (charge level, location)</li><li>Information of my current 3d print job</li></ol><p>The WebAPI uses OAuth 2.0 for both the Graph API and Fitbit API. I only implemented the refresh-token logic, so there is no Authorization logic (using the Microsoft.Owin library). Instead I used <a href=https://www.postman.com/downloads/>Postman</a> to get my user authorization code, access code and refresh token. You can <a href=https://docs.microsoft.com/en-us/graph/auth-register-app-v2>read more about this here</a>. As instructed in the code you only need to enter these tokens once&mldr; The WebAPI will store and update the tokens into AzureKeyVault on its own.</p><p>If this project help you reduce time to develop, you can give me a cup of coffee &#x1f604;</p><p><a href="https://www.paypal.com/cgi-bin/webscr?cmd=_donations&amp;business=FEAWWGSBYLMZL&amp;currency_code=EUR&amp;source=url"><img src=https://img.shields.io/badge/Donate-PayPal-green.svg alt=Donate></a></p><p><img src=/img/donate.png alt=qr></p></div></div></div></div></div></div></div><script src=https://jurjanbrust.github.io/js/jquery.min.js></script><script src=https://jurjanbrust.github.io/js/bootstrap.min.js></script><script src=https://jurjanbrust.github.io/js/jquery.cookie.js></script><script src=https://jurjanbrust.github.io/js/ekko-lightbox.js></script><script src=https://jurjanbrust.github.io/js/jquery.scrollTo.min.js></script><script src=https://jurjanbrust.github.io/js/masonry.pkgd.min.js></script><script src=https://jurjanbrust.github.io/js/imagesloaded.pkgd.min.js></script><script src=https://jurjanbrust.github.io/js/owl.carousel.min.js></script><script src=https://jurjanbrust.github.io/js/front.js></script></body></html>